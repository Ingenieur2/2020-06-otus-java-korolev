# 2020-06-otus-java-korolev

###Влияние параметров VM  на время работы приложения
Главным критерием оценки было общее время работы приложения.<br>
Для исследований использовался ПК со следующими параметрами:<br>
Intel Xeon CPU E5-2643 0 @3.30GHz (2 процессора)<br>
ОЗУ 64 Гб<br>
Жесткий диск SSD OSZ-Vertex4 ATA Device 480 Gb<br>
Windows 7 Professional Service Pack 1.

<br>Изменение оперативной памяти:<br>
    Если напрямую не указывать Heap, то сборщики выбирают оптимальное значение для максимально быстрого выполнения всей работы приложения и он меняется в ходе выполнения приложения. Причем для G1 есть существенное улучшение. В нашем случае примерно одинаково показывают себя SerialGC и ParallelGC, G1 – отстает по времени в 2.36 раза (с простоями Thread.sleep(10)) и в 2.92 раза (без простоев Thread.sleep(10)). Однако максимальные значения Heap в течение работы существенно отличаются: SerialGC – 1024 Mb, ParallelGC – 6142 Mb, G1 – 828 Mb. 

<br>Задание величины Heap:<br>
Существует оптимальная величина Heap, при которой время работы минимально.
Если памяти совсем мало, то сборки мусора идут постоянно – young + old; их число в разы больше, чем при оптимальном Heap. При чрезмерно большом Heap сборок мусора существенно меньше, но приложение работает дольше засчет большего времени работы с памятью. Одинаковая картина наблюдается для каждого сборщика с учетом и без учета Thread.sleep(10).

<br>Изменение времени желаемой паузы:<br>
Изменение –XX:MaxPauseMillis практически не влияет на общее время работы приложения (отклонения в пределах погрешности) во всех случаях, кроме случая с ParallelGC и маленьким Heap (512 Mb в нашем случае). Здесь уменьшение желаемой паузы дает улучшение общего времени работы до 20%.
<br>Изменение числа ядер процессора:<br>
Данное изменение по разному влияет на работу приложения с разными сборщиками мусора. Использование максимального числа ядер процессоров (16) нецелесообразно: только в случае с G1 и Heap 512 Mb (без учета Thread.sleep(10)) наблюдается улучшение по времени работы в 15% (относительно default параметров).
Использование 1-ого ядра процессора незначительно увеличивает общее время работы (до 22% для G1 и Heap 512 Mb (с учетом Thread.sleep(10)).
В целом максимальные отклонения от default значений наблюдаются у G1 – поэтому для остальных сборщиков нет смысла перезадавать –XX:ConcGCThreads=n. Для G1 не стоит задавать один поток для работы приложения.

<br>OutOfMemory<br>
Создано медленное подтекание по памяти. При всех одинаковых параметрах для каждого сборщика мусора (Heap 512 Mb) и остальных default параметрах дольше всех держится SerialGC и проходит наибольшее количество циклов. G1 – в режиме с учетом Thread.sleep(10) почти также долго работает, в то время как без учета Thread.sleep(10) выходит за пределы OutOfMemory самым первым. Поэтому оптимальным сборщиком мусора для выявления OutOfMemory в приложении является ParallelGC, но для приложений с непрерывной работой (Thread.sleep(0)) также подойдет G1.
<br>
###<br>Влияние параметров VM  на величину StopTheWorld<br>
В начале работы приложения Serial GC делает большие паузы, потом разгоняется, кроме случая с маленьким heap - в нем постоянно идут большие задержки. В целом, в Runtime при SerialGC имеются минимальные задержки (в пределах 1 мс). Однако с увеличением Heap число коротких пауз уменьшается пропорционально увеличению heap. К 60000 - коротких пауз нет совсем.
Для всех сборщиков мусора наблюдается оптимальная величина Heap, при которой приложение имеет минимальное время отклика; эта же величина  близка к оптимальной с точки зрения общего времени работы приложения.

<br>
Изменение времени желаемой паузы:<br>
Изменение времени желаемой паузы для SerialGC и ParallelGC не  позволило выявить явной зависимости и требует проведения серии подробных испытаний и сбора статистики для каждого приложения индивидуально.
Для G1  увеличение –XX:MaxPauseMillis приводит к увеличению отклика на 35% (с учетом Thread.sleep(10)) и на 45% (без учета Thread.sleep(10)).
Также для G1 (в случае маленького Heap) существует некоторая величина, при которой возникает резкое увеличение паузы (~ 2,3 раза).
<br>
<br> Изменение числа ядер процессора:<br>
Данный вид регулирования также не позволил выявить зависимости и требует серии детальных исследований для каждого конкретного случая, чтобы наверняка указать оптимальное количество требуемых процессоров. Однако, как мне кажется, не стоит указывать –XX:ConcGCThreads=max, ввиду малого влияния на режим работы приложения.

<br>OutOfMemory<br>
При всех одинаковых параметрах для каждого сборщика мусора (Heap 512 Mb) и остальных default параметрах максимальное время отклика наблюдается у SerialGC (>130ms); значения у ParallelGC  и у G1 (с учетом Thread.sleep(10)) примерно в два раза ниже, а в случае непрерывной работы G1 – значения уже в 4 раза ниже (34 ms).

<br>
Как итог, хочется отметить, что default параметры сборщиков мусора достаточно хорошо оптимизированы, и существенного улучшения в скорости работы и желаемого отклика достичь будет очень сложно. При необходимости стоит указывать оптимальное (или по возможности ближайшее к нему) значение Heap и StopTheWorld.