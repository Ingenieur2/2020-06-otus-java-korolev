# 2020-06-otus-java-korolev

###Влияние параметров VM  на время работы приложения
Главным критерием оценки было общее время работы приложения.<br>
Для исследований использовался ПК со следующими параметрами:<br>
Intel Xeon CPU E5-2643 0 @3.30GHz (2 процессора)<br>
ОЗУ 64 Гб<br>
Жесткий диск SSD OSZ-Vertex4 ATA Device 480 Gb<br>
Windows 7 Professional Service Pack 1.

<br>Изменение оперативной памяти:<br>
    Если напрямую не указывать Heap, то сборщики выбирают оптимальное значение для максимально быстрого выполнения всей работы приложения и он меняется в ходе выполнения приложения. Причем для G1 есть существенное улучшение. В нашем случае примерно одинаково показывают себя SerialGC и ParallelGC, G1 – отстает по времени в 2.36 раза (с простоями Thread.sleep(10)) и в 2.92 раза (без простоев Thread.sleep(10)). Однако максимальные значения Heap в течение работы существенно отличаются: SerialGC – 1024 Mb, ParallelGC – 6142 Mb, G1 – 828 Mb. 

<br>Задание величины Heap:<br>
Существует оптимальная величина Heap, при которой время работы минимально.
Если памяти совсем мало, то сборки мусора идут постоянно – young + old; их число в разы больше, чем при оптимальном Heap. При чрезмерно большом Heap сборок мусора существенно меньше, но приложение работает дольше засчет большего времени работы с памятью. Одинаковая картина наблюдается для каждого сборщика с учетом и без учета Thread.sleep(10).

<br>Изменение времени желаемой паузы:<br>
Изменение –XX:MaxPauseMillis практически не влияет на общее время работы приложения (отклонения в пределах погрешности) во всех случаях, кроме случая с ParallelGC и маленьким Heap (512 Mb в нашем случае). Здесь уменьшение желаемой паузы дает улучшение общего времени работы до 20%.
<br>Изменение числа ядер процессора:<br>
Данное изменение по разному влияет на работу приложения с разными сборщиками мусора. Использование максимального числа ядер процессоров (16) нецелесообразно: только в случае с G1 и Heap 512 Mb (без учета Thread.sleep(10)) наблюдается улучшение по времени работы в 15% (относительно default параметров).
Использование 1-ого ядра процессора незначительно увеличивает общее время работы (до 22% для G1 и Heap 512 Mb (с учетом Thread.sleep(10)).
В целом максимальные отклонения от default значений наблюдаются у G1 – поэтому для остальных сборщиков нет смысла перезадавать –XX:ConcGCThreads=n. Для G1 не стоит задавать один поток для работы приложения.

<br>OutOfMemory<br>
Создано медленное подтекание по памяти. При всех одинаковых параметрах для каждого сборщика мусора (Heap 512 Mb) и остальных default параметрах дольше всех держится SerialGC и проходит наибольшее количество циклов. G1 – в режиме с учетом Thread.sleep(10) почти также долго работает, в то время как без учета Thread.sleep(10) выходит за пределы OutOfMemory самым первым. Поэтому оптимальным сборщиком мусора для выявления OutOfMemory в приложении является ParallelGC, но для приложений с непрерывной работой (Thread.sleep(0)) также подойдет G1.